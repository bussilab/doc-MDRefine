<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>MDRefine.data_loading API documentation</title>
<meta name="description" content="Tools n. 1: `data_loading`.
It loads data into the `data` object.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MDRefine.data_loading</code></h1>
</header>
<section id="section-intro">
<p>Tools n. 1: <code>data_loading</code>.
It loads data into the <code>data</code> object.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MDRefine.data_loading.check_and_skip"><code class="name flex">
<span>def <span class="ident">check_and_skip</span></span>(<span>data, *, stride=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_and_skip(data, *, stride=1):
    &#34;&#34;&#34;
    This function is an internal tool used in `load_data` to modify input `data`:

    - weights are normalized;

    - it appends observables computed through forward models (if any) to `data.mol[name_sys].g`;
    
    - if ` hasattr(data.mol[name_sys], &#39;selected_obs&#39;)`: it removes non-selected observables from `data.mol[name_sys].forward_qs`;
    
    - select frames with given `stride`;
    
    - count n. experiments and n. frames (`data.mol[name_sys].n_frames` and `data.mol[name_sys].n_experiments`)
    and check corresponding matching.
    &#34;&#34;&#34;

    # output_data = {}
    # output_data[&#39;global&#39;] = data.properties

    system_names = data.properties.system_names

    for name_sys in system_names:

        my_data = data.mol[name_sys]

        &#34;&#34;&#34; 1. compute observables from .forward_qs through forward model and include them in .g &#34;&#34;&#34;

        if hasattr(my_data, &#39;forward_model&#39;) and (my_data.forward_model is not None):
            if not hasattr(my_data, &#39;g&#39;):
                my_data.g = {}

            if hasattr(my_data, &#39;selected_obs&#39;):
                for type_name in my_data.forward_qs.keys():
                    my_data.forward_qs[type_name] = my_data.forward_qs[type_name]  # [:,my_data.selected_obs[name][type_name]]

            if hasattr(my_data, &#39;selected_obs&#39;):
                selected_obs = my_data.selected_obs
            else:
                selected_obs = None

            out = my_data.forward_model(np.array(data.properties.forward_coeffs_0), my_data.forward_qs, selected_obs)

            if type(out) is tuple:
                out = out[0]

            if not hasattr(my_data, &#39;g&#39;):
                my_data.g = {}
            for name in out.keys():
                my_data.g[name] = out[name]

        &#34;&#34;&#34; 2. check data &#34;&#34;&#34;

        if not hasattr(my_data, &#39;g&#39;):

            my_list = [x2 for x in list(data.properties.cycle_names.values()) for x2 in x]
                
            assert hasattr(data, &#39;cycle&#39;), &#39;error: missing MD data for system&#39; + name_sys
            assert name_sys in my_list, &#39;error: missing MD data for system&#39; + name_sys

            for s2 in data.properties.cycle_names:
                if name_sys in data.properties.cycle_names[s2]:
                    assert hasattr(data.cycle[s2], &#39;gexp_DDG&#39;), &#39;error: missing gexp DDG for cycle&#39; % s2

        &#34;&#34;&#34; 3. count number of systems and number of experimental data; check: same number of frames &#34;&#34;&#34;

        my_data.n_experiments = {}

        if hasattr(my_data, &#39;gexp&#39;):

            &#34;&#34;&#34; if no value for sigma_exp is provided, this is by default assumed to be 10^-6 times
            the standard deviation of the corresponding time series &#34;&#34;&#34;
            for name in my_data.gexp.keys():
                if (my_data.gexp[name].ndim == 1):
                    my_data.gexp[name] = my_data.gexp[name].reshape(-1, 1)
                
                if (my_data.gexp[name].ndim == 2 and my_data.gexp[name].shape[1] == 1):
                    std_vec = 1e-6*np.std(my_data.g[name], axis=0).reshape(-1, 1)
                    my_data.gexp[name] = np.hstack([my_data.gexp[name], std_vec])

            my_data.n_experiments = {}
            for kind in my_data.gexp.keys():
                my_data.n_experiments[kind] = np.shape(my_data.gexp[kind])[0]

            &#34;&#34;&#34; check same number of observables as in data.gexp &#34;&#34;&#34;

            if hasattr(my_data, &#39;g&#39;):
                for kind in my_data.g.keys():
                    if my_data.ref[kind] == &#39;&gt;&lt;&#39;:
                        if not np.shape(my_data.gexp[kind+&#39; LOWER&#39;])[0] == np.shape(my_data.g[kind])[1]:
                            print(&#39;error: different number of observables for (system, kind) = (%s,%s)&#39; % (name_sys, kind))
                        if not np.shape(my_data.gexp[kind+&#39; UPPER&#39;])[0] == np.shape(my_data.g[kind])[1]:
                            print(&#39;error: different number of observables for (system, kind) = (%s,%s)&#39; % (name_sys, kind))
                    else:
                        if not np.shape(my_data.gexp[kind])[0] == np.shape(my_data.g[kind])[1]:
                            print(&#39;error: different number of observables for (system, kind) = (%s,%s)&#39; % (name_sys, kind))

        &#34;&#34;&#34; check number of frames &#34;&#34;&#34;

        n_frames = np.shape(my_data.weights)[0]

        if not (hasattr(my_data, &#39;g&#39;) or hasattr(my_data, &#39;forward_qs&#39;) or hasattr(data.cycle[name_sys[:-3]], &#39;gexp_DDG&#39;)):
            print(&#39;error: missing MD data&#39;)
        else:

            err_string = [
                &#39;error: different number of frames for observable (system,kind) = (%s,%s)&#39;,
                &#39;error: different number of frames for forward_qs (system,kind) = (%s,%s)&#39;,
                &#39;error: different number of frames for force field terms of system %s&#39;]

            if hasattr(my_data, &#39;g&#39;):
                for kind in my_data.g.keys():
                    assert np.shape(my_data.g[kind])[0] == n_frames, err_string[0] % (name_sys, kind)

            if hasattr(my_data, &#39;forward_qs&#39;):
                for kind in my_data.forward_qs.keys():
                    assert np.shape(my_data.forward_qs[kind])[0] == n_frames, err_string[1] % (name_sys, kind)

        if hasattr(my_data, &#39;f&#39;):
            assert len(my_data.f) == n_frames, err_string[2] % name_sys

        &#34;&#34;&#34; 4. do you want to skip frames? select stride (stride = 1 by default) &#34;&#34;&#34;

        if not stride == 1:
            if hasattr(my_data, &#39;f&#39;):
                my_data.f = my_data.f[::stride]
            my_data.weights = my_data.weights[::stride]
            my_data.weights = my_data.weights/np.sum(my_data.weights)

            if hasattr(my_data, &#39;g&#39;):
                for name in my_data.g.keys():
                    my_data.g[name] = my_data.g[name][::stride]

            if hasattr(my_data, &#39;forward_qs&#39;):
                for name in my_data.forward_qs.keys():
                    my_data.forward_qs[name] = my_data.forward_qs[name][::stride]

        &#34;&#34;&#34; 5. count number of frames &#34;&#34;&#34;

        my_data.n_frames = np.shape(my_data.weights)[0]

        # output_data[name_sys] = my_data
        data.mol[name_sys] = my_data
        del my_data

    # if hasattr(data.properties, &#39;cycle_names&#39;):
    #     for name in data.properties.cycle_names:
            # output_data[name] = data[name]

    return data  # output_data</code></pre>
</details>
<div class="desc"><p>This function is an internal tool used in <code><a title="MDRefine.data_loading.load_data" href="#MDRefine.data_loading.load_data">load_data()</a></code> to modify input <code>data</code>:</p>
<ul>
<li>
<p>weights are normalized;</p>
</li>
<li>
<p>it appends observables computed through forward models (if any) to <code>data.mol[name_sys].g</code>;</p>
</li>
<li>
<p>if <code>hasattr(data.mol[name_sys], 'selected_obs')</code>: it removes non-selected observables from <code>data.mol[name_sys].forward_qs</code>;</p>
</li>
<li>
<p>select frames with given <code>stride</code>;</p>
</li>
<li>
<p>count n. experiments and n. frames (<code>data.mol[name_sys].n_frames</code> and <code>data.mol[name_sys].n_experiments</code>)
and check corresponding matching.</p>
</li>
</ul></div>
</dd>
<dt id="MDRefine.data_loading.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>infos, *, stride=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(infos, *, stride=1):
    &#34;&#34;&#34;
    This tool loads data from specified directory as indicated by the user in `infos`
    to a dictionary `data` of classes, which includes `data.properties` (global properties) and `data[system_name]`;
    for alchemical calculations, there is also `data[cycle_name]`.
    &#34;&#34;&#34;

    print(&#39;loading data from directory...&#39;)

    data = my_data(infos)

    # check and skip frames with stride

    data = check_and_skip(data, stride=stride)

    # def tot_n_experiments(data):
    #     tot = 0
    #     for k in system_names:
    #         for item in data[k].n_experiments.values():
    #             tot += item
    #     return tot

    # data.properties.system_names = system_names
    # data.properties.tot_n_experiments = tot_n_experiments

    # if hasattr(data.properties, &#39;ff_correction&#39;) and (data.properties.ff_correction == &#39;linear&#39;):
    #     list_names_ff_pars = []
    #     for k in data.properties.system_names:
    #         if hasattr(data[k], &#39;f&#39;):
    #             [list_names_ff_pars.append(x) for x in data[k].f.keys() if x not in list_names_ff_pars]
    #     data.properties.names_ff_pars = list_names_ff_pars

    # elif &#39;names_ff_pars&#39; in infos[&#39;global&#39;].keys():
    #     data.properties.names_ff_pars = infos[&#39;global&#39;][&#39;names_ff_pars&#39;]

    print(&#39;done&#39;)

    return data</code></pre>
</details>
<div class="desc"><p>This tool loads data from specified directory as indicated by the user in <code>infos</code>
to a dictionary <code>data</code> of classes, which includes <code>data.properties</code> (global properties) and <code>data[system_name]</code>;
for alchemical calculations, there is also <code>data[cycle_name]</code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MDRefine.data_loading.data_class"><code class="flex name class">
<span>class <span class="ident">data_class</span></span>
<span>(</span><span>info, path_directory, name_sys)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class data_class:
    &#34;&#34;&#34;
    Data object of a molecular system.

    Parameters
    ----------
    info: dict
        Dictionary for the information about the data of `name_sys` molecular system in `path_directory`. 

    path_directory: str
        String for the path of the directory with data of the molecular system `name_sys`.

    name_sys: str
        Name of the molecular system taken into account.
    
    --------

    Returns
    --------
    temperature : float
        Value for the temperature at which the trajectory is simulated.
    
    gexp : dict
        Dictionary of Numpy 2-dimensional arrays (N x 2); `gexp[j,0]` is the experimental value of the j-th observable, `gexp[j,1]` is the corresponding uncertainty;
        the size N depends on the type of observable.
    
    names : dict
        Dictionary of Numpy 1-dimensional arrays of length N with the names of the observables of each type.
    
    ref : dict
        Dictionary of strings with signs `&#39;=&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&lt;&#39; used to define the chi2 to compute,
        depending on the observable type.
    
    g : dict
        Dictionary of Numpy 2-dimensional arrays (M x N), where `g[name][i,j]` is the j-th observable of that type computed in the i-th frame.
    
    forward_qs : dict
        Dictionary of Numpy 2-dimensional arrays (M x N) with the quantities required for the forward model.
    
    forward_model: function
        Function for the forward model, whose input variables are the forward-model coefficients `fm_coeffs` and the `forward_qs` dictionary;
        a third optional argument is the `selected_obs` (dictionary with indices of selected observables).
    
    weights: array_like
        Numpy 1-dimensional array of length M with the weights (not required to be normalized).
    
    f: array_like
        Numpy 2-dimensional array (M x P) of terms required to compute the force-field correction,
        where P is the n. of parameters `pars` and M is the n. of frames.
    
    ff_correction: function
        Function for the force-field correction, whose input variables are the force-field correction parameters `pars` and the `f` array (sorted consistently with each other).
    &#34;&#34;&#34;
    def __init__(self, info, path_directory, name_sys):

        # 0. temperature

        if &#39;temperature&#39; in info.keys():
            self.temperature = info[&#39;temperature&#39;]
            &#34;&#34;&#34;`float` value for the temperature&#34;&#34;&#34;
        else:
            self.temperature = 1.0

        # 1. gexp (experimental values) and names of the observables

        if &#39;g_exp&#39; in info.keys():

            self.gexp = {}
            &#34;&#34;&#34;dictionary of `numpy.ndarray` containing gexp values and uncertainties&#34;&#34;&#34;
            self.names = {}
            &#34;&#34;&#34;dictionary of `numpy.ndarray` containing names of experimental observables&#34;&#34;&#34;
            self.ref = {}  # if data.gexp are boundary or puntual values
            &#34;&#34;&#34;dictionary of `numpy.ndarray` containing references&#34;&#34;&#34;

            if info[&#39;g_exp&#39;] is None:
                if info[&#39;DDGs&#39;][&#39;if_DDGs&#39;] is False:
                    print(&#39;error, some experimental data is missing&#39;)
            else:
                if info[&#39;g_exp&#39;] == []:
                    info[&#39;g_exp&#39;] = [f[:-4] for f in os.listdir(path_directory+&#39;%s/g_exp&#39; % name_sys)]

                for name in info[&#39;g_exp&#39;]:
                    if type(name) is tuple:
                        if len(name) == 5:
                            for i in range(2):
                                if name[2*i+2] == &#39;&gt;&#39;:
                                    s = &#39; LOWER&#39;
                                elif name[2*i+2] == &#39;&lt;&#39;:
                                    s = &#39; UPPER&#39;
                                else:
                                    print(&#39;error in the sign of gexp&#39;)
                                    return

                                if os.path.isfile(path_directory+&#39;%s/g_exp/%s%s.npy&#39; % (name_sys, name[0], name[2*i+1])):
                                    self.gexp[name[0]+s] = np.load(
                                        path_directory+&#39;%s/g_exp/%s%s.npy&#39; % (name_sys, name[0], name[2*i+1]))
                                elif os.path.isfile(path_directory+&#39;%s/g_exp/%s%s&#39; % (name_sys, name[0], name[2*i+1])):
                                    self.gexp[name[0]+s] = numpy.loadtxt(
                                        path_directory+&#39;%s/g_exp/%s%s&#39; % (name_sys, name[0], name[2*i+1]))

                            self.ref[name[0]] = &#39;&gt;&lt;&#39;

                        elif name[1] == &#39;=&#39; or name[1] == &#39;&gt;&#39; or name[1] == &#39;&lt;&#39;:
                            if os.path.isfile(path_directory+&#39;%s/g_exp/%s.npy&#39; % (name_sys, name[0])):
                                self.gexp[name[0]] = np.load(path_directory+&#39;%s/g_exp/%s.npy&#39; % (name_sys, name[0]))
                            elif os.path.isfile(path_directory+&#39;%s/g_exp/%s&#39; % (name_sys, name[0])):
                                self.gexp[name[0]] = numpy.loadtxt(path_directory+&#39;%s/g_exp/%s&#39; % (name_sys, name[0]))
                            self.ref[name[0]] = name[1]

                        else:
                            print(&#39;error on specified sign of gexp&#39;)
                            return

                    else:
                        if os.path.isfile(path_directory+&#39;%s/g_exp/%s.npy&#39; % (name_sys, name)):
                            self.gexp[name] = np.load(path_directory+&#39;%s/g_exp/%s.npy&#39; % (name_sys, name))
                        elif os.path.isfile(path_directory+&#39;%s/g_exp/%s&#39; % (name_sys, name)):
                            self.gexp[name] = numpy.loadtxt(path_directory+&#39;%s/g_exp/%s&#39; % (name_sys, name))
                        self.ref[name] = &#39;=&#39;

                    if type(name) is tuple:
                        name = name[0]
                    if os.path.isfile(path_directory+&#39;%s/names/%s.npy&#39; % (name_sys, name)):
                        self.names[name] = np.load(path_directory+&#39;%s/names/%s.npy&#39; % (name_sys, name))
                    elif os.path.isfile(path_directory+&#39;%s/names/%s&#39; % (name_sys, name)):
                        self.names[name] = numpy.loadtxt(path_directory+&#39;%s/names/%s&#39; % (name_sys, name))

        # 2. g (observables)

        if &#39;obs&#39; in info.keys():

            self.g = {}

            if info[&#39;obs&#39;] is not None:
                if info[&#39;obs&#39;] == []:
                    info[&#39;obs&#39;] = [f[:-4] for f in os.listdir(path_directory+&#39;%s/observables&#39; % name_sys)]
                for name in info[&#39;obs&#39;]:
                    if os.path.isfile(path_directory+&#39;%s/observables/%s.npy&#39; % (name_sys, name)):
                        self.g[name] = np.load(path_directory+&#39;%s/observables/%s.npy&#39; % (name_sys, name), mmap_mode=&#39;r&#39;)
                    elif os.path.isfile(path_directory+&#39;%s/observables/%s&#39; % (name_sys, name)):
                        self.g[name] = numpy.loadtxt(path_directory+&#39;%s/observables/%s&#39; % (name_sys, name))

        # 3. forward_qs (quantities for the forward model) and forward_model

        if &#39;forward_qs&#39; in info.keys():

            # in this way, you can define forward model either with or without selected_obs (c)
            def my_forward_model(a, b, c=None):
                try:
                    out = info[&#39;forward_model&#39;](a, b, c)
                    for s in c.keys():
                        if list(c[s]) == []:
                            del out[s]
                except:
                    assert c is None, &#39;you have selected_obs but the forward model is not suitably defined!&#39;
                    out = info[&#39;forward_model&#39;](a, b)
                return out

            self.forward_model = my_forward_model  # info[&#39;forward_model&#39;]

            self.forward_qs = {}

            for name in info[&#39;forward_qs&#39;]:
                if info[&#39;forward_qs&#39;] is not None:
                    if info[&#39;forward_qs&#39;] == []:
                        info[&#39;forward_qs&#39;] = [f[:-4] for f in os.listdir(path_directory+&#39;%s/forward_qs&#39; % name_sys)]
                    for name in info[&#39;forward_qs&#39;]:
                        if os.path.isfile(path_directory+&#39;%s/forward_qs/%s.npy&#39; % (name_sys, name)):
                            self.forward_qs[name] = np.load(
                                path_directory+&#39;%s/forward_qs/%s.npy&#39; % (name_sys, name), mmap_mode=&#39;r&#39;)
                        elif os.path.isfile(path_directory+&#39;%s/forward_qs/%s&#39; % (name_sys, name)):
                            self.forward_qs[name] = numpy.loadtxt(path_directory+&#39;%s/forward_qs/%s&#39; % (name_sys, name))

        # 4. weights (normalized)

        if os.path.isfile(path_directory+&#39;%s/weights.npy&#39; % name_sys):
            self.weights = np.load(path_directory+&#39;%s/weights.npy&#39; % name_sys)
        elif os.path.isfile(path_directory+&#39;%s/weights&#39; % name_sys):
            self.weights = numpy.loadtxt(path_directory+&#39;%s/weights&#39; % name_sys)
        else:
            if (&#39;obs&#39; in info.keys()) and not (info[&#39;obs&#39;] is None):
                name = list(self.g.keys())[0]
                self.weights = np.ones(len(self.g[name]))
            elif (&#39;forward_qs&#39; in info.keys()) and not (info[&#39;forward_qs&#39;] is None):
                name = list(self.forward_qs.keys())[0]
                self.weights = np.ones(len(self.forward_qs[info[&#39;forward_qs&#39;][0]]))
            else:
                print(&#39;error: missing MD data for %s!&#39; % name_sys)

        self.weights = self.weights/np.sum(self.weights)

        # 5. f (force field correction terms) and function

        if (&#39;ff_correction&#39; in info.keys()) and (info[&#39;ff_correction&#39;] is not None):

            if info[&#39;ff_correction&#39;] == &#39;linear&#39;:
                self.ff_correction = lambda pars, f: np.matmul(f, pars)
            else:
                self.ff_correction = info[&#39;ff_correction&#39;]

            ff_path = path_directory + &#39;%s/ff_terms&#39; % name_sys
            self.f = np.load(ff_path + &#39;.npy&#39;)</code></pre>
</details>
<div class="desc"><p>Data object of a molecular system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary for the information about the data of <code>name_sys</code> molecular system in <code>path_directory</code>.</dd>
<dt><strong><code>path_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>String for the path of the directory with data of the molecular system <code>name_sys</code>.</dd>
<dt><strong><code>name_sys</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the molecular system taken into account.</dd>
</dl>
<hr>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>temperature</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the temperature at which the trajectory is simulated.</dd>
<dt><strong><code>gexp</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of Numpy 2-dimensional arrays (N x 2); <code>gexp[j,0]</code> is the experimental value of the j-th observable, <code>gexp[j,1]</code> is the corresponding uncertainty;
the size N depends on the type of observable.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of Numpy 1-dimensional arrays of length N with the names of the observables of each type.</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of strings with signs `'=', '&gt;', '&lt;', '&gt;&lt;' used to define the chi2 to compute,
depending on the observable type.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of Numpy 2-dimensional arrays (M x N), where <code>g[name][i,j]</code> is the j-th observable of that type computed in the i-th frame.</dd>
<dt><strong><code>forward_qs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of Numpy 2-dimensional arrays (M x N) with the quantities required for the forward model.</dd>
<dt><strong><code>forward_model</code></strong> :&ensp;<code>function</code></dt>
<dd>Function for the forward model, whose input variables are the forward-model coefficients <code>fm_coeffs</code> and the <code>forward_qs</code> dictionary;
a third optional argument is the <code>selected_obs</code> (dictionary with indices of selected observables).</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Numpy 1-dimensional array of length M with the weights (not required to be normalized).</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Numpy 2-dimensional array (M x P) of terms required to compute the force-field correction,
where P is the n. of parameters <code>pars</code> and M is the n. of frames.</dd>
<dt><strong><code>ff_correction</code></strong> :&ensp;<code>function</code></dt>
<dd>Function for the force-field correction, whose input variables are the force-field correction parameters <code>pars</code> and the <code>f</code> array (sorted consistently with each other).</dd>
</dl></div>
</dd>
<dt id="MDRefine.data_loading.data_cycle_class"><code class="flex name class">
<span>class <span class="ident">data_cycle_class</span></span>
<span>(</span><span>cycle_name, DDGs_exp, info)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class data_cycle_class:
    &#34;&#34;&#34;
    Data object of a thermodynamic cycle.
    
    Parameters
    ----------
    cycle_name : str
        String with the name of the thermodynamic cycle taken into account.
    
    DDGs_exp : pandas.DataFrame
        Pandas.DataFrame with the experimental values and uncertainties of Delta Delta G in labelled thermodynamic cycles.

    info: dict
        Dictionary for the information about the temperature of `cycle_name` thermodynamic cycle. 

    --------
    Returns
    --------
    gexp_DDG : list
        List of two elements: the experimental value and uncertainty of the Delta Delta G.
    
    temperature : float
        Value of temperature.
    &#34;&#34;&#34;
    def __init__(self, cycle_name, DDGs_exp, info):

        self.gexp_DDG = [DDGs_exp.loc[:, cycle_name].iloc[0], DDGs_exp.loc[:, cycle_name].iloc[1]]

        if &#39;temperature&#39; in info.keys():
            self.temperature = info[&#39;temperature&#39;]
            &#34;&#34;&#34;Temperature.&#34;&#34;&#34;
        else:
            self.temperature = 1.0
            &#34;&#34;&#34;Temperature&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Data object of a thermodynamic cycle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cycle_name</code></strong> :&ensp;<code>str</code></dt>
<dd>String with the name of the thermodynamic cycle taken into account.</dd>
<dt><strong><code>DDGs_exp</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas.DataFrame with the experimental values and uncertainties of Delta Delta G in labelled thermodynamic cycles.</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary for the information about the temperature of <code>cycle_name</code> thermodynamic cycle.</dd>
</dl>
<hr>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gexp_DDG</code></strong> :&ensp;<code>list</code></dt>
<dd>List of two elements: the experimental value and uncertainty of the Delta Delta G.</dd>
<dt><strong><code>temperature</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of temperature.</dd>
</dl></div>
</dd>
<dt id="MDRefine.data_loading.datapropertiesclass"><code class="flex name class">
<span>class <span class="ident">datapropertiesclass</span></span>
<span>(</span><span>infos, path_directory)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class datapropertiesclass:
    &#34;&#34;&#34;Global data, common to all the investigated molecular systems.
    
    Parameters
    ----------

    info_global: dict
        Dictionary with global information:
        `info_global[&#39;system_names&#39;]` with list of names of the molecular systems;
        `info_global[&#39;cycle_names&#39;]` with list of names of the thermodynamic cycles;
        `info_global[&#39;forward_coeffs&#39;]` with string for the file name of forward coefficients;
        `info_global[&#39;names_ff_pars&#39;]` with list of names of the force-field correction coefficients.

    path_directory: str
        String with the path of the directory with input files.

    --------
    Returns
    --------
    system_names : list
        List of names of the investigated molecular systems.
    
    forward_coeffs_0 : list
        List of the forward-model coefficients.
    
    names_ff_pars : list
        List of names of the force-field correction parameters.

    cycle_names : list
        List of names of the investigated thermodynamic cycles.
    &#34;&#34;&#34;
    def __init__(self, infos, path_directory):

        self.infos = infos

        info_global = infos[&#39;global&#39;]

        self.system_names = info_global[&#39;system_names&#39;]

        if &#39;forward_coeffs&#39; in info_global.keys():
            temp = pandas.read_csv(path_directory + info_global[&#39;forward_coeffs&#39;], header=None)
            temp.index = temp.iloc[:, 0]
            self.forward_coeffs_0 = temp.iloc[:, 1]

            # temp = pandas.read_csv(path_directory+&#39;%s&#39; % info_global[&#39;forward_coeffs&#39;], index_col=0)
            # if temp.shape[0] == 1:
            #     self.forward_coeffs_0 = temp.iloc[:, 0]
            # else:
            #     self.forward_coeffs_0 = temp.squeeze()

        if &#39;names_ff_pars&#39; in info_global.keys():
            self.names_ff_pars = info_global[&#39;names_ff_pars&#39;]
        
        if &#39;cycle_names&#39; in info_global.keys():
            self.cycle_names = info_global[&#39;cycle_names&#39;]

    def tot_n_experiments(self, data):
        &#34;&#34;&#34;This method computes the total n. of experiments.&#34;&#34;&#34;
        
        tot = 0

        for k in self.system_names:
            for item in data.mol[k].n_experiments.values():
                tot += item
        return tot</code></pre>
</details>
<div class="desc"><p>Global data, common to all the investigated molecular systems.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info_global</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with global information:
<code>info_global['system_names']</code> with list of names of the molecular systems;
<code>info_global['cycle_names']</code> with list of names of the thermodynamic cycles;
<code>info_global['forward_coeffs']</code> with string for the file name of forward coefficients;
<code>info_global['names_ff_pars']</code> with list of names of the force-field correction coefficients.</dd>
<dt><strong><code>path_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>String with the path of the directory with input files.</dd>
</dl>
<hr>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>system_names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of names of the investigated molecular systems.</dd>
<dt><strong><code>forward_coeffs_0</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the forward-model coefficients.</dd>
<dt><strong><code>names_ff_pars</code></strong> :&ensp;<code>list</code></dt>
<dd>List of names of the force-field correction parameters.</dd>
<dt><strong><code>cycle_names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of names of the investigated thermodynamic cycles.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="MDRefine.data_loading.datapropertiesclass.tot_n_experiments"><code class="name flex">
<span>def <span class="ident">tot_n_experiments</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tot_n_experiments(self, data):
    &#34;&#34;&#34;This method computes the total n. of experiments.&#34;&#34;&#34;
    
    tot = 0

    for k in self.system_names:
        for item in data.mol[k].n_experiments.values():
            tot += item
    return tot</code></pre>
</details>
<div class="desc"><p>This method computes the total n. of experiments.</p></div>
</dd>
</dl>
</dd>
<dt id="MDRefine.data_loading.my_data"><code class="flex name class">
<span>class <span class="ident">my_data</span></span>
<span>(</span><span>infos)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class my_data:
    def __init__(self, infos):
        
        system_names = infos[&#39;global&#39;][&#39;system_names&#39;]
        path_directory = infos[&#39;global&#39;][&#39;path_directory&#39;]
        if not path_directory[-1] == &#39;/&#39;: path_directory += &#39;/&#39;
        
        # global data
        self.properties = datapropertiesclass(infos, path_directory)

        # data for each molecular system

        self.mol = {}

        for name_sys in system_names:

            print(&#39;loading &#39;, name_sys)
            
            if name_sys in infos.keys():
                info = {**infos[name_sys], **infos[&#39;global&#39;]}
            else:
                info = infos[&#39;global&#39;]
    
            self.mol[name_sys] = data_class(info, path_directory, name_sys)

        # data for thermodynamic cycles (alchemical calculations)

        if &#39;cycle_names&#39; in infos[&#39;global&#39;].keys():

            logZs = pandas.read_csv(path_directory + &#39;alchemical/logZs&#39;, index_col=0, header=None)

            for name in infos[&#39;global&#39;][&#39;cycle_names&#39;]:
                for s in [&#39;MD&#39;, &#39;MS&#39;, &#39;AD&#39;, &#39;AS&#39;]:
                    key = name + &#39;_&#39; + s
                    if key in logZs.index:
                        self.mol[key].logZ = logZs.loc[key][1]
                    else:
                        self.mol[key].logZ = 0.0

            self.cycle = {}

            DDGs_exp = pandas.read_csv(path_directory + &#39;alchemical/DDGs&#39;, index_col=0)

            for name in infos[&#39;global&#39;][&#39;cycle_names&#39;]:
                if name in infos.keys():
                    info = {**infos[name], **infos[&#39;global&#39;]}
                else:
                    info = infos[&#39;global&#39;]

                self.cycle[name] = data_cycle_class(name, DDGs_exp, info)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MDRefine" href="index.html">MDRefine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MDRefine.data_loading.check_and_skip" href="#MDRefine.data_loading.check_and_skip">check_and_skip</a></code></li>
<li><code><a title="MDRefine.data_loading.load_data" href="#MDRefine.data_loading.load_data">load_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MDRefine.data_loading.data_class" href="#MDRefine.data_loading.data_class">data_class</a></code></h4>
</li>
<li>
<h4><code><a title="MDRefine.data_loading.data_cycle_class" href="#MDRefine.data_loading.data_cycle_class">data_cycle_class</a></code></h4>
</li>
<li>
<h4><code><a title="MDRefine.data_loading.datapropertiesclass" href="#MDRefine.data_loading.datapropertiesclass">datapropertiesclass</a></code></h4>
<ul class="">
<li><code><a title="MDRefine.data_loading.datapropertiesclass.tot_n_experiments" href="#MDRefine.data_loading.datapropertiesclass.tot_n_experiments">tot_n_experiments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MDRefine.data_loading.my_data" href="#MDRefine.data_loading.my_data">my_data</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
